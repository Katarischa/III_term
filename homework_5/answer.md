### 1. Что такое идиома RAII? Как расшифровывается эта аббревиатура?

_*Resource Acquisition Is Initialization*_ (Получение ресурса есть инициализация). Идиома заключается в том, что в конструкторе объект получает доступ к какому либо ресурсу, а в деструкторе данный ресурс освобождается.

### 2. Что такое конструктор, копирующий конструктор, деструктор, геттер, сеттер? Как определить конструктор и деструктор по умолчанию?

2.1. Конструктор -- функция выполняемая при инициализации класса. Конструктор пристраивает полям класса значения в соответствии с переданными во время инициализации аргументами.

2.2. Копирующий конструктор -- конструктор выполняемый когда аргументом при инициализации класса является другой объект того же класса. Также выполняется во время операции присвоения.

Конструктор по умолчанию:
```c++
Vector() = default 
```
2.3. Деструктор -- функция, выполняемая при выходе из класса. Здесь мы освобождаем ресурсы, чтобы не было утечек памяти

Деструктор по умолчанию:
```c++
~DynamicVector(){
    delete dimension;   // Удаляем числа
    delete[] components // Удаляем элементы массива
}
```

2.4 Геттеры -- методы, возвращающие поля (константная ссылка или копия. Нельзя менять возвращенные значения!)

```c++
const std::vector<double>& get_components() const{
    return components;          //пример геттера
}
```

2.5 Сеттеры -- методы, изменяющие поля. Если значения поля связано со значениями других полей, сеттер меняет и другие поля.

```c++
void set_dimension(unsigned new_dimension) {
    dimention = new_dimention;
    components.resize(new_dimention);       //пример сеттера
}       
```

### 3. Почему поля класса принято делать приватными? Какой метод называется константным?

1. Поля класса приватные, поскольку при изменении некоторых значений в элементах многофайловых проектов мы можем сломать связь между файлами, из-за чего проект сломается и просто перестанет работать.
2. Метод константный, если поля класса остаются такими же.

### 4. С какой целью проекты делают многофайловыми? Почему происходит разделение кода на .h файлы и .cpp файлы?

Проекты делают многофайловыми, чтобы:
1. Повысить читаемость кода
2. Ускорить процесс компиляции (чтобы не компилировать одно и то же по 2 кругу, пользуемся CMakeList.txt )
3. Удобнее осуществить разделение работ  

Просмотрев .h файл можно понять, какие функции выполняет класс (это ускоряет работу). реализация этой функции лежит в .cpp

### 5. Какие три этапа проходит код при превращении в исполняемый файл? Расскажите, что в них происходит

1. Препроцессинг --  выполняются директивы предпроцессора
2. Компиляция --  перевод кода на машинный язык
3. Сборка (линковка) -- отдельные скомпилированные модули соединяются в один файл
